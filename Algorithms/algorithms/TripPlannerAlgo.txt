package algorithms;

import map.*;
import robot.Robot;
import robot.RobotConstants;

import java.awt.*;
import java.awt.geom.Line2D;
import java.util.*;
import java.util.List;

/**
 * This class will be used for planning the maneuver from one point to another
 */
public class TripPlannerAlgo {
    public int[][] printArray;
    public ArrayList<Node> totalPathToPrint = new ArrayList<>();
    private final Arena arena;
    private final int numCells = (MapConstants.ARENA_WIDTH / MapConstants.OBSTACLE_WIDTH) + MapConstants.ARENA_BORDER_SIZE * 2;
    private Node[][][] grid; // grid dimensions: x,y,direction (of which there are 4: 0=east,1=north,2=west,3=south)
    //private int[][][] turningArray; // array to keep track of whether turns are possible at this position
    private final Map<Node, Node> predMap;
    private int[] endPosition; // use this to access the end position of our car.
    private ArrayList<Node> nodePath;

    private PriorityQueue<Node> visitQueue; // min heap priority queue for nodes in the frontier
    private Node currentNode;
    private double totalCost = 0;

    public TripPlannerAlgo(Arena arena) {
        this.arena = arena;
        this.predMap = new HashMap<>();
        int robotX = arena.getRobot().getX();
        int robotY = arena.getRobot().getY();
        int robotDirection = arena.getRobot().getRobotDirectionAngle();
        endPosition = new int[]{robotX, robotY, robotDirection};
        this.visitQueue = new PriorityQueue<>(new NodeComparator());
    }

    public int[] getEndPosition() {
        return endPosition;
    }

    /**
     * Clear the map and any stored values
     */
    public void clear() {
        predMap.clear();
        constructMap();

        // initialize the arrays
        int numCells = (MapConstants.ARENA_WIDTH / MapConstants.OBSTACLE_WIDTH) + MapConstants.ARENA_BORDER_SIZE * 2;
        //this.greedyCostArray = new double[numCells][numCells][4];
        for (int i = 0; i < numCells; i++) {
            for (int j = 0; j < numCells; j++) {
                for (int k = 0; k < 4; k++) {
                    grid[j][i][k].setCost(RobotConstants.MAX_COST, RobotConstants.MAX_COST);
                }
            }
        }

        // initialize frontier queue
        visitQueue.clear();
    }

    /**
     * Checks if a node can be visited.
     */
    private boolean canVisit(Node node) {
        return !node.isPicture() && !node.isVirtualObstacle() && !node.isVisited();
    }


    /**
     * Calculate the number of nodes required to perform a turn.
     * i.e. if turn radius = 24 cm,
     * X X X
     * X
     * X   O
     * <p>
     * Assuming the car is aligned to the center of the grid (i.e. x=5,y=5),
     * 5+24 = 29; the turning circle will be centered at x=29,y=5. (If we are facing north and turning right)
     * Thus, the robot will require 3 grid units worth of space in either direction to complete a turn.
     * i.e. after changing directions, will require ceiling(turnRadius/10)-1 blocks of room to turn.
     */
    private int calculateTurnSizeX() {
        double gridSize = MapConstants.OBSTACLE_WIDTH;
        // get the largest turn radius measure of the four measures
        double largestRadius = Math.max(RobotConstants.LEFT_TURN_RADIUS_X, RobotConstants.RIGHT_TURN_RADIUS_X);//Math.max(RobotConstants.LEFT_TURN_RADIUS_X, RobotConstants.LEFT_TURN_RADIUS_Y),Math.max(RobotConstants.RIGHT_TURN_RADIUS_X, RobotConstants.RIGHT_TURN_RADIUS_Y));
        return (int) Math.ceil(largestRadius / gridSize) + 1;
    }

    /**
     * Calculate the number of nodes required to turn in the Y direction
     */
    private int calculateTurnSizeY() {
        double gridSize = MapConstants.OBSTACLE_WIDTH;
        // get the largest turn radius measure of the four measures
        double largestRadius = Math.max(RobotConstants.LEFT_TURN_RADIUS_Y, RobotConstants.RIGHT_TURN_RADIUS_Y);//Math.max(RobotConstants.LEFT_TURN_RADIUS_X, RobotConstants.LEFT_TURN_RADIUS_Y),Math.max(RobotConstants.RIGHT_TURN_RADIUS_X, RobotConstants.RIGHT_TURN_RADIUS_Y));
        return (int) Math.ceil(largestRadius / gridSize) + 1;
    }

    private int newCalculateTurnSizeX() {
        double gridSize = MapConstants.OBSTACLE_WIDTH;
        // get the largest turn radius measure of the four measures
        double largestRadius = 5;//Math.max(RobotConstants.LEFT_TURN_RADIUS_X, RobotConstants.LEFT_TURN_RADIUS_Y),Math.max(RobotConstants.RIGHT_TURN_RADIUS_X, RobotConstants.RIGHT_TURN_RADIUS_Y));
        return (int) Math.ceil(largestRadius / gridSize) + 1;
    }

    /**
     * Calculate the number of nodes required to turn in the Y direction
     */
    private int newCalculateTurnSizeY() {
        double gridSize = MapConstants.OBSTACLE_WIDTH;
        // get the largest turn radius measure of the four measures
        double largestRadius = 5;//Math.max(RobotConstants.LEFT_TURN_RADIUS_X, RobotConstants.LEFT_TURN_RADIUS_Y),Math.max(RobotConstants.RIGHT_TURN_RADIUS_X, RobotConstants.RIGHT_TURN_RADIUS_Y));
        return (int) Math.ceil(largestRadius / gridSize) + 1;
    }

    /**
     * given the node of a picture obstacle, get the goal node position
     */
    private int[] getGoalNodePosition(int x, int y, int dir) {
        int dist = AlgoConstants.DISTANCE_FROM_GOAL;
        int[] coords = new int[3];
        switch (dir) {
            case 0:
                coords[0] = x + dist;
                coords[1] = y;
                coords[2] = 180;
                break;
            case 90:
                coords[0] = x;
                coords[1] = y - dist;
                coords[2] = 270;
                break;
            case 180:
                coords[0] = x - dist;
                coords[1] = y;
                coords[2] = 0;
                break;
            case 270:
                coords[0] = x;
                coords[1] = y + dist;
                coords[2] = 90;
                break;
            default:
                return null;
        }
        return coords;
    }

    /**
     * Plans a path from the car position to the selected picture obstacle using a modified A* algorithm.
     * <p>
     * Generating the 4 possible successors of the current cell
     * <p>
     * N
     * |
     * |
     * W----Cell----E
     * |
     * |
     * S
     * <p>
     * Cell-->Popped Cell (i, j)
     * N -->  North       (i-1, j)
     * S -->  South       (i+1, j)
     * E -->  East        (i, j+1)
     * W -->  West        (i, j-1)
     * <p>
     * Rules:
     * A turn cannot occur if the unit has not traveled in its current direction n nodes,
     * where n is the minimum number of nodes required for a turn to occur.
     * <p>
     * A turn cannot occur if there are obstacles within the turning area.
     * <p>
     * The robot must be facing the direction specified by endDirection by the end of the path.
     * <p>
     * input: the x,y, and direction of the picture obstacle, the robot's turn radius
     */
    public ArrayList<MoveType> planPath(int startX, int startY, int startAngle, int pictureX, int pictureY, int pictureDirInDegrees, boolean isPicturePos, boolean doBacktrack, boolean print, boolean sidestep) {
        if (0 > startX || startX >= numCells || 0 > startY || startY >= numCells) { // start is outside of bounds
            this.totalCost += 9999;
            return null;
        }
        clear();
        int endX, endY, endAngleDimension;
        ArrayList<MoveType> path = null;
        boolean goalFound = false;
        if (isPicturePos) {
            int[] goal = getGoalNodePosition(pictureX, pictureY, pictureDirInDegrees);
            endX = goal[0];
            endY = goal[1];
            int endDirInDegrees = goal[2];             // false since goal node has not yet been found
            endAngleDimension = angleToDimension(endDirInDegrees);  // which dimension of the 3d array does the goal node lie in
        } else {
            endX = pictureX;
            endY = pictureY;
            endAngleDimension = angleToDimension(pictureDirInDegrees);
        }

        // test if goal node s reachable
        if (!isValidLocation(endX, endY, endAngleDimension)) return null;

        Node goalNode = grid[endY][endX][endAngleDimension];        // fetch the goal node from the grid array.
        int maxTurnCountX = calculateTurnSizeX();            // get the number of grids that the car needs to move straight after changing directions (for a legal turn)
        int maxTurnCountY = calculateTurnSizeY();
        // this is the counter for the turnArray. Only when turnArray[y][x] = turnMaxCount is a turn allowed to be made.
        int x, y, dim;
        Node nextNode;
        int[] forwardLocation, leftLocation, rightLocation, backwardLocation;
        int nextX, nextY, nextDim, currentTurnCount;
        double currentGCost, hCost, gCost;
        // lets start searching

        int angleDimension = angleToDimension(startAngle);

        this.currentNode = grid[startY][startX][angleDimension];
        this.visitQueue.add(currentNode);
        grid[startY][startX][angleDimension].setCost(0, 0);

        while (!goalFound && !visitQueue.isEmpty()) {
            currentNode = visitQueue.remove(); // Fetch the head of the priority queue

            x = currentNode.getX();
            y = currentNode.getY();
            dim = currentNode.getDim(); // 0 = east, 1 = north, 2 = west, 3 = south (counter-clockwise)
            currentGCost = currentNode.getGCost();
            if (currentNode == goalNode) {      // we have found the goal
                goalFound = true; // otherwise, we are good to go (search over)!
                endPosition = new int[]{x, y, dim * 90};
                break;
            }
//            System.out.println("Current Node info is " + x + " " + y + " " + dim);
//            System.out.println("Goal Node info (bot center) is " + goalNode.getX() + " " + goalNode.getY() + " " + goalNode.getDim());
//            System.out.println("========================================");
            /*
            the forward location coordinates, as well as their dimensions, will be RELATIVE to the bot
             */
            forwardLocation = getForwardNode(x, y, dim);
            leftLocation = getLeftNode(x, y, dim, maxTurnCountX, maxTurnCountY);
            rightLocation = getRightNode(x, y, dim, maxTurnCountX, maxTurnCountY);
            backwardLocation = getBackwardNode(x, y, dim);
            List<int[]> locations = new ArrayList<int[]>();
            locations.add(forwardLocation);
            locations.add(leftLocation);
            locations.add(rightLocation);
            locations.add(backwardLocation);
            for (int[] location : locations) {
                if (location != null) { // if this is a valid location to search, add it to the queue
                    nextX = location[0];
                    nextY = location[1];
                    nextDim = location[2];
//                    System.out.println("nextY: " + nextY + " nextX: " + nextX + " nextDim: " + nextDim);
                    nextNode = grid[nextY][nextX][nextDim];

                    gCost = currentGCost + greedy(currentNode, nextNode);
                    hCost = heuristic(currentNode, goalNode, endAngleDimension);


                    // if we have already added this node, only change it if the newly found path is better.
                    if (gCost < nextNode.getGCost()) {
                        predMap.put(nextNode, currentNode);
                        nextNode.setCost(hCost, gCost); // set the cost for the next node and then add to the priority queue
                        visitQueue.add(nextNode);
                    }
                }
            }
            if (!sidestep) {
                currentNode.setHasBeenVisited(true);
            }
        }
        // when we exit the loop, check if the goal has been found or not.
        if (!goalFound) {
            this.totalCost += 9999;
            return null;
        }
        if (doBacktrack) {
            path = backtrack(goalNode, print);
        }
        if (print && doBacktrack) {
            System.out.println("Total cost: " + goalNode.getGCost());
            System.out.println("Nodes expanded: " + predMap.size());
        }
        this.totalCost += goalNode.getGCost();
        return path;
    }

    public int[] getNewXY(int obstacleAngle, int x, int y, int switchDir){
        // todo for the second iteration of this, try the other direction, so keep a flag above for this
        if (obstacleAngle == 0 || obstacleAngle==2){
            return new int[]{x, y + switchDir};
        }
        else{
            return new int[]{x + switchDir, y};
        }
    }

    /**
     * Calculate the coordinates to reverse to
     */
    public void clearCost() {
        this.totalCost = 0;
    }

    public double getTotalCost() {
        return totalCost;
    }

    private int[] getForwardNode(int x, int y, int dim) {
        int[] pair;
        switch (dim) {
            case 0: // east, x+1,y
                pair = new int[]{x + 1, y, dim};
                break;
            case 1: // north, x,y-1
                pair = new int[]{x, y - 1, dim};
                break;
            case 2: // west, x-1,y
                pair = new int[]{x - 1, y, dim};
                break;
            case 3: // south, x,y+1
                pair = new int[]{x, y + 1, dim};
                break;
            default: // error
                pair = null;
                break;
        }
        if (pair != null && isValidLocation(pair[0], pair[1], dim)) return pair;
        else return null;
    }

    private int[] getBackwardNode(int x, int y, int dim) {
        int[] pair;
        switch (dim) {
            case 0: // east, x+1,y
                pair = new int[]{x - 1, y, dim};
                break;
            case 1: // north, x,y-1
                pair = new int[]{x, y + 1, dim};
                break;
            case 2: // west, x-1,y
                pair = new int[]{x + 1, y, dim};
                break;
            case 3: // south, x,y-1
                pair = new int[]{x, y - 1, dim};
                break;
            default: // error
                pair = null;
                break;
        }
        if (pair != null && isValidLocation(pair[0], pair[1], dim)) return pair;
        else return null;
    }

    // get node to the left of the current node (considering the direction facing)
    private int[] getLeftNode(int x, int y, int dim, int maxTurnCountX, int maxTurnCountY) {
        int[] pair;
        int[] check0; // used to be the 'original' pair
        int[] check1; // make sure this location is not occupied in order to make the turn
        int[] check2;
        int[] check3;
        int nextPosLeft = maxTurnCountX - 1;
        int nextPosStraight = maxTurnCountY - 1;
        switch (dim) {
            case 0: // east, x,y-1 (facing north)
                pair = new int[]{x + 1, y, 1};
                check0 = new int[]{x + nextPosStraight, y - nextPosLeft, 1}; //{x, y - 1, 1};
                check1 = new int[]{x + nextPosStraight, y, 1};
//                check2 = new int[]{x + nextPosStraight, y - 1, 1};
                check3 = new int[]{x , y - 1, 1};
                break;
            case 1: // north, x-1,y (facing west)
                pair = new int[]{x, y - 1, 2};
                check0 = new int[]{x - nextPosLeft, y - nextPosStraight, 2}; //{x - 1, y, 2};
                check1 = new int[]{x, y - nextPosStraight, 1};
//                check2 = new int[]{x -1, y - nextPosStraight, 1};
                check3 = new int[]{x -1, y, 1};
                break;
            case 2: // west, x,y+1 (facing south)
                pair = new int[]{x - 1, y, 3};
                check0 = new int[]{x - nextPosStraight, y + nextPosLeft, 3}; //{x, y + 1, 3};
                check1 = new int[]{x - nextPosStraight, y, 3};
//                check2 = new int[]{x - nextPosStraight, y+1, 3};
                check3 = new int[]{x , y+1, 1};
                break;
            case 3: // south, x+1,y (facing east)
                pair = new int[]{x, y + 1, 0};
                check0 = new int[]{x + nextPosLeft, y + nextPosStraight, 0}; //{x + 1, y, 0};
                check1 = new int[]{x, y + nextPosStraight, 0};
//                check2 = new int[]{x+1, y + nextPosStraight, 0};
                check3 = new int[]{x+1, y, 0};
                break;
            default: // error
                pair = null;
                check0 = null;
                check1 = null;
                check2 = null;
                check3 = null;
                break;
        }
        if (pair != null && isValidLocation(pair[0], pair[1], pair[2]) &&
                isValidLocation(check0[0], check0[1], check0[2]) && isValidLocation(check1[0], check1[1], check1[2]) &&
                isValidLocation(check3[0], check3[1], check3[2]))
            return pair;
        else return null;
    }

    private int[] getRightNode(int x, int y, int dim, int maxTurnCountX, int maxTurnCountY) {
        int[] pair;
        int[] check0; // used to be the 'original' pair
        int[] check1;
        int[] check2;
        int[] check3;
        int nextPosRight = maxTurnCountX - 1;
        int nextPosStraight = maxTurnCountY - 1;
        switch (dim) {
            case 0: // east, x,y+1 (facing south)
                pair = new int[]{x + 1, y, 3};
                check0 = new int[]{x + nextPosStraight, y + nextPosRight, 3}; //{x, y + 1, 3};
                check1 = new int[]{x + nextPosStraight, y, 3};
//                check2 = new int[]{x + nextPosStraight, y+1, 3};
                check3 = new int[]{x , y+1, 3};
                break;
            case 1: // north, x+1,y (facing east)
                pair = new int[]{x, y - 1, 0};
                check0 = new int[]{x + nextPosRight, y - nextPosStraight, 0}; //{x + 1, y, 0};
                check1 = new int[]{x, y - nextPosStraight, 0};
//                check2 = new int[]{x+1, y - nextPosStraight, 0};
                check3 = new int[]{x+1, y , 0};
                break;
            case 2: // west, x,y-1 (facing north)
                pair = new int[]{x - 1, y, 1};
                check0 = new int[]{x - nextPosStraight, y - nextPosRight, 1}; //{x, y - 1, 1};
                check1 = new int[]{x - nextPosStraight, y, 1};
//                check2 = new int[]{x - nextPosStraight, y-1, 1};
                check3 = new int[]{x, y-1, 1};
                break;
            case 3: // south, x-1,y (facing west)
                pair = new int[]{x, y + 1, 2};
                check0 = new int[]{x - nextPosRight, y + nextPosStraight, 2}; //{x - 1, y, 2};
                check1 = new int[]{x, y + nextPosStraight, 2};
//                check2 = new int[]{x-1, y + nextPosStraight, 2};
                check3 = new int[]{x-1, y, 2};

                break;
            default: // error
                pair = null;
                check0 = null;
                check1 = null;
//                check2 = null;
                check3 = null;
                break;
        }
        if (pair != null && isValidLocation(pair[0], pair[1], pair[2]) &&
                isValidLocation(check3[0], check3[1], check3[2]) && isValidLocation(check0[0], check0[1], check0[2]) && isValidLocation(check1[0], check1[1], check1[2]))
            return pair;
        else return null;
    }

    /**
     * Heuristic algorithm using manhattan distance from start node to end node.
     */
    private double heuristic(Node n1, Node n2, int endDim) {
        int abs1 = Math.abs(n1.getX() - n2.getX());
        int abs2 = Math.abs(n1.getY() - n2.getY());
        // prefer nodes in the same direction as the end direction
        return Math.sqrt(Math.pow(abs1, 2) + Math.pow(abs2, 2)) * RobotConstants.MOVE_COST;
//        return (abs1 + abs2) * RobotConstants.MOVE_COST; //* directionWeight;
    }

    /**
     * Greedy algorithm to calculate the path cost. Additional weight
     * on turning to prefer a straight path when possible.
     */
    private double greedy(Node n1, Node n2) {
        int turnCost = 0;
        int cost = RobotConstants.MOVE_COST;

        // check to see if turning is required to get to that direction (not in the same angle dimension)
        if (n1.getDim() != n2.getDim()) {
            turnCost = RobotConstants.TURN_COST_90;
        } else {
            switch (n1.getDim()) {
                case 0:
                    if (n1.getX() > n2.getX())
                        cost = RobotConstants.REVERSE_COST;
                    break;
                case 1:
                    if (n1.getY() > n2.getY())
                        cost = RobotConstants.REVERSE_COST;
                    break;
                case 2:
                    if (n1.getX() < n2.getX())
                        cost = RobotConstants.REVERSE_COST;
                    break;
                case 3:
                    if (n1.getY() < n2.getY())
                        cost = RobotConstants.REVERSE_COST;
                    break;
            }
        }
        // return the sum of the cost to move 1 node + the cost to turn (if turning is done)
        return cost + turnCost;
    }

    /**
     * backtrack from the goal node to get the path
     */
    private ArrayList<MoveType> backtrack(Node end, boolean print) {
        Node curr, prev;
        ArrayList<Node> path = new ArrayList<>();
        ArrayList<MoveType> pathSegments = new ArrayList<>();
        path.add(end);
        curr = end;
        int midpoint = MapConstants.OBSTACLE_WIDTH / 2;

        // diffX and diffY define the IDEAL 'unit' differences made when the robot turns 'forward left' when initially facing North
        // or 'forward right'. In reality, the y difference is 7cm, but the algo reads in terms of 10cm unit,
        // therefore diffY is 10
        int diffX = 0; //newCalculateTurnSizeX() * MapConstants.OBSTACLE_WIDTH - MapConstants.OBSTACLE_WIDTH;
        int diffY = 10; //newCalculateTurnSizeY() * MapConstants.OBSTACLE_WIDTH - MapConstants.OBSTACLE_WIDTH;

        double[] lineEnd = new double[]{end.getX() * MapConstants.OBSTACLE_WIDTH + midpoint, end.getY() * MapConstants.OBSTACLE_WIDTH + midpoint}; // keep track of the end point(x2,y2) of the line segment
        double[] lineStart = new double[2];
        String stringDir = "";

        int prevDir; // = curr.getDim();
        int currDir;
        double radiusX, radiusY; // the radius we want to use for the turn.
        boolean turnLeft;
        int dirInDegrees;
        boolean reversing;

        // the way this loop works is by skipping past the nodes until it finds a couple where
        // the direction changes. when that happens, BEFORE constructing the arc of turn, it will construct
        // the line that connect the endOfTheNewTurn to the startOfTheOldTurn
        // and then only will it construct the arcOfTheNewTurn
        // note that, since this is a backtrack, the OldTurn comes in front of the NewTurn in the real robot movement
        // before this while loop is started, LineEnd would be the final place the robot should be
        while (curr != null) {
            reversing = false;
            path.add(curr);
            // the predMap is a hashmap structured like this:
            // key = nextNode, value = previousNode
            // in the above, 'next' means the actual next Node the robot would travel to in the movement
            // therefore, 'curr' is in front of 'prev' in the real movement
            // therefore, 'LineStart', which is from 'curr' is in front of 'LineEnd' in reality
            prev = predMap.get(curr); // get the previous node in the backtrack
            currDir = curr.getDim();

            if (prev == null) { // if this is the last node, handle the special case.
                lineStart[0] = curr.getX() * MapConstants.OBSTACLE_WIDTH + midpoint;
                lineStart[1] = curr.getY() * MapConstants.OBSTACLE_WIDTH + midpoint;
                switch (currDir) { // check if reversing
                    case 0: // east
                        if (lineEnd[0] < lineStart[0]) reversing = true;
                        break;
                    case 1: // north
                        if (lineEnd[1] > lineStart[1]) reversing = true;
                        break;
                    case 2: // west
                        if (lineEnd[0] > lineStart[0]) reversing = true;
                        break;
                    case 3: // south
                        if (lineEnd[1] < lineStart[1]) reversing = true;
                        break;
                    default: // wut
                }
                pathSegments.add(new LineMove(lineStart[0], lineStart[1], lineEnd[0], lineEnd[1], currDir * 90, true, reversing));
            } else if (prev.getDim() != currDir) { // otherwise, only look for points where direction changes to construct the line segments
                prevDir = prev.getDim();
                lineStart[0] = curr.getX() * MapConstants.OBSTACLE_WIDTH + midpoint;
                lineStart[1] = curr.getY() * MapConstants.OBSTACLE_WIDTH + midpoint;

                // check if it's a left or right turn being made
                dirInDegrees = prev.getDim() * 90;

                if ((dirInDegrees + 90) % 360 == curr.getDim() * 90) {
                    turnLeft = true;
                } else {
                    turnLeft = false;
                }

                radiusX = 0;
                radiusY = 7;

                // The lineEnd, at this point, is created by the previous Node in the previous iteration of this
                // while loop.
                // LineStart, in this switch case, is the starting point of the robot that exists after the robot
                // has made some turn
                // therefore, the LineStart value needs to be adjusted using the unit value of the turn "diffX"
                // as well as the real granular value of the turn "radiusX"
                // THE BELOW COMMENTS ARE ONLY AN EXAMPLE, RADIUSX AND DIFFX ARE 0
                // in this case, LET the radiusX is 7cm, the unit value of the turn diffX is 10cm
                // there needs to be a compensation of 3cm. This is because, lets say, for a forward left turn
                // the algo would want the bot to move 10cm on the x axis. However, it only moves 7cm on the x axis
                // in reality. Since the robot ends up facing east (case 0), the lineStart must minus (10cm-7cm=3cm)
                // from it's value, to reflect the reality of where the STM would reach
                // since the LineStart starts 3cm less, and the LineEnd remains the same when passed to LineMove,
                // the STM is therefore instructed to move 3cm EXTRA
                // note that the 'diffX/Y/radiusX/Y' are badly named, because they are applied differently based
                // on the facing of the robot.
                // in reality, the 7cm explanation above is for diffY, so my bad for writing it here lol
                switch (currDir) {
                    case 0: // east
                        stringDir = "EAST";
                        lineStart[0] -= diffX - radiusX;
                        if (lineEnd[0] < lineStart[0]) reversing = true;
                        break;
                    case 1: // north
                        stringDir = "NORTH";
                        lineStart[1] += diffX - radiusX;
                        if (lineEnd[1] > lineStart[1]) reversing = true;
                        break;
                    case 2: // west
                        stringDir = "WEST";
                        lineStart[0] += diffX - radiusX;
                        if (lineEnd[0] > lineStart[0]) reversing = true;
                        break;
                    case 3: // south
                        stringDir = "SOUTH";
                        lineStart[1] -= diffX - radiusX;
                        if (lineEnd[1] < lineStart[1]) reversing = true;
                        break;
                    default: // wut
                }
                pathSegments.add(new LineMove(lineStart[0], lineStart[1], lineEnd[0], lineEnd[1], dirInDegrees, true, reversing));

                // now, calculate the turn between the two points.
                // Note: start of the curve = prev location (lineEnd of the next line). End of the curve = lineStart coordinates
                lineEnd[0] = prev.getX() * MapConstants.OBSTACLE_WIDTH + midpoint;
                lineEnd[1] = prev.getY() * MapConstants.OBSTACLE_WIDTH + midpoint;
                switch (prevDir) {
                    case 0: // east
                        lineEnd[0] += diffY - radiusY;
                        break;
                    case 1: // north
                        lineEnd[1] -= diffY - radiusY;
                        break;
                    case 2: // west
                        lineEnd[0] -= diffY - radiusY;
                        break;
                    case 3: // south
                        lineEnd[1] += diffY - radiusY;
                        break;
                    default: // wut
                }

                // once reaching this point, both the linestart and lineend coords have been corrected by the
                // real granular turn radius
                pathSegments.add(new ArcMove(lineEnd[0], lineEnd[1], lineStart[0], lineStart[1], dirInDegrees, radiusX, radiusY, false, turnLeft, false, stringDir));
            }
            curr = prev;
        }
        Collections.reverse(path); // reverse the path and put it in the correct order
        totalPathToPrint.addAll(path);
//        if (print) printPath2(path);
        nodePath = path; // save the path for sending to android team
        Collections.reverse(pathSegments);

        for (MoveType i : pathSegments) System.out.println(i.toString());
        return pathSegments;
    }

    public ArrayList<Node> getNodePath() {
        return nodePath;
    }

    /**
     Will check if the node goes out of bounds, then will check if it can be visited
     , meaning is it some obstacle or virtual obstacle
     */
    private boolean isValidLocation(int x, int y, int dim) {
        if (x >= 0 && x < numCells && y >= 0 && y < numCells ) {
            if (y >= MapConstants.ARENA_BORDER_SIZE && y <= numCells - MapConstants.ARENA_BORDER_SIZE) {
                Node n = grid[y][x][dim];
                return canVisit(n);
            }
        }
        return false;
    }

    /**
     * Instantiate the grid map.
     */
    public void constructMap() {
        ArrayList<PictureObstacle> pictureObstacleList = arena.getObstacles();

        grid = new Node[numCells][numCells][4]; // instantiate the grid (we assume it is a square grid), and that we have 4 possible cardinal directions
        // fill up the grid map
        for (int i = 0; i < numCells; i++) {
            for (int j = 0; j < numCells; j++) {
                for (int k = 0; k < 4; k++) {
                    grid[i][j][k] = new Node(false, false, j, i, k);
                }
            }
        }

        int angleDimension, x, y, id;
        // set picture nodes to isObstacle = true
        for (PictureObstacle pictures : pictureObstacleList) {
            x = pictures.getX();
            y = pictures.getY();
            id = pictureObstacleList.indexOf(pictures);
            angleDimension = angleToDimension(pictures.getImadeDirectionAngle()); // calculate the correct angle dimension the picture node is set in.

            grid[y][x][angleDimension].setPicture(true);
            grid[y][x][angleDimension].setPictureId(id);
            for (int i = 0; i < 4; i++) {
                grid[y][x][i].setVirtualObstacle(true);
            }
            int[][] pairs = getVirtualObstaclePairs(x, y, AlgoConstants.BORDER_THICKNESS);
            int xVirtual, yVirtual;
            // set the surrounding nodes to be virtual obstacles
            for (int[] pair : pairs) {
                xVirtual = pair[0];
                yVirtual = pair[1];
                for (int i = 0; i < 4; i++) {
                    if (xVirtual >= 0 && xVirtual < numCells && yVirtual >= 0 && yVirtual < numCells) { // is the given pair a valid location
                        grid[yVirtual][xVirtual][i].setVirtualObstacle(true);
                    }
                }
            }
        }

        // initialize the arrays
        int numCells = (MapConstants.ARENA_WIDTH / MapConstants.OBSTACLE_WIDTH) + MapConstants.ARENA_BORDER_SIZE * 2;

        for (int i = 0; i < numCells; i++) {
            for (int j = 0; j < numCells; j++) {
                for (int k = 0; k < 4; k++) {
                    grid[j][i][k].setCost(RobotConstants.MAX_COST, RobotConstants.MAX_COST);
                }
            }
        }
        grid[endPosition[1]][endPosition[0]][endPosition[2] / 90].setCost(0, 0);
    }

    private int angleToDimension(int angle) {
        return angle / 90;
    }

    /**
     * get the locations of the virtual obstacles in terms of pairs [x,y] given a specific x,y
     */
    private int[][] getVirtualObstaclePairs(int x, int y, int thickness) {
        int numCol = 1 + 2 * thickness;
        int numPairs = numCol * numCol - 1; // how many pairs we must generate

        int[][] pairArray = new int[numPairs][];
        int[][] coordinateArray = new int[numCol][numCol];
        int dim = coordinateArray.length;
        int relativeCenter = dim / 2;
        int counter = 0;
        for (int y1 = 0; y1 < dim; y1++) {
            for (int x1 = 0; x1 < dim; x1++) {
                if (x1 != relativeCenter || y1 != relativeCenter) {
                    pairArray[counter] = new int[]{x + x1 - thickness, y + y1 - thickness};
                    counter++;
                }
            }
        }
        return pairArray;
    }
    public int colorPrevY(int prevY, int prevX, int y){
        int directionOfColor = 1;
        while (prevY != y) {
            if (prevY >= y) {
                directionOfColor = -1;
            }
            else{
                directionOfColor = 1;
            }
            prevY += directionOfColor;
            printArray[prevY][prevX] = 1;
        }
        return prevY;
    }

    public int colorPrevX(int prevY, int prevX, int x){
        int directionOfColor = 1;
        while (prevX != x) {
            if (prevX >= x) {
                directionOfColor = -1;
            }
            else{
                directionOfColor = 1;
            }
            prevX += directionOfColor;
            printArray[prevY][prevX] = 1;
        }
        return prevX;
    }
    public void colorPrevNodes(Node curr, Node prev){
        int dir = curr.getDim();
        int prevDir = prev.getDim();
        int y = curr.getY();
        int x = curr.getX();
        int prevY = prev.getY();
        int prevX = prev.getX();
        // if curr is right/left, prev is up/down, colour Y first
        if (dir != prevDir && (dir == 0 || dir == 2)) {
            prevY = colorPrevY(prevY, prevX, y);
            prevX = colorPrevX(prevY, prevX, x);
        } else if (dir != prevDir && (dir == 1 || dir == 3)) {
            prevX = colorPrevX(prevY, prevX, x);
            prevY = colorPrevY(prevY, prevX, y);

        }
    }
    public int[][] printPath2(List<Node> path) {

        printArray = new int[numCells][numCells];
        for (int y = 0; y < numCells; y++) {
            for (int x = 0; x < numCells; x++) {
                printArray[y][x] = 0;
            }
        }
        Node prevNode = path.get(0);
        for (Node n : path) {
            int dir = n.getDim();
            colorPrevNodes(n, prevNode);
            switch (dir) {
                case 0: // right
                    printArray[n.getY()][n.getX()] = 1;
                    break;
                case 1: // up
                    printArray[n.getY()][n.getX()] = 1;
                    break;
                case 2: // left
                    printArray[n.getY()][n.getX()] = 1;
//                    printArray[n.getY()][n.getX()+1] = 1;
//                    printArray[n.getY()][n.getX()+2] = 1;
//                    printArray[n.getY()][n.getX()+3] = 1;
//                    printArray[n.getY()+1][n.getX()+3] = 1;
                    break;
                case 3: // down
                    printArray[n.getY()][n.getX()] = 1;
                    break;
                default:
                    printArray[n.getY()][n.getX()] = 1;
                    break;
            }
            prevNode = n;
            if (n.getX() == arena.getRobot().getX() && n.getY() == arena.getRobot().getY())
                printArray[n.getY()][n.getX()] = 1;
        }
        printArray[path.get(0).getY()][path.get(0).getX()] = 1;

        for (int y = 0; y < numCells; y++) {
            for (int x = 0; x < numCells; x++) {
                System.out.print(printArray[y][x]);
            }
            System.out.println();
        }
        return printArray;
    }

    // code to do a reverse motion if possible.
    public int[] getReversePos(int x, int y, int dim) {
        int[] pair;
        switch (dim) {
            case 0: // east, x+1,y
                pair = new int[]{x - 1, y, dim};
                break;
            case 1: // north, x,y-1
                pair = new int[]{x, y + 1, dim};
                break;
            case 2: // west, x-1,y
                pair = new int[]{x + 1, y, dim};
                break;
            case 3: // south, x,y-1
                pair = new int[]{x, y - 1, dim};
                break;
            default: // error
                pair = null;
                break;
        }
        if (pair != null && canGo(pair[0], pair[1], dim)) return pair;
        else return null;
    }

    // just check if the node is not a virtual obstacle or a picture obstacle.
    private boolean canGo(int x, int y, int dim) {
        if (x >= 0 && x < numCells && y >= 0 && y < numCells) {
            Node n = grid[y][x][dim];
            return !n.isPicture() && !n.isVirtualObstacle();
        } else {
            return false;
        }
    }
}

